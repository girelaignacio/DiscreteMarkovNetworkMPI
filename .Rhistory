panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
# 2. Create the heatmap with ggplot2
ggplot(data = melted_matrix, aes(x = Column, y = Row, fill = Value)) +
geom_tile() + # Use geom_tile for the heatmap cells
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) + # Color scale
coord_equal() +  # Important for symmetric matrices: ensures cells are square
theme_minimal() + # Clean theme
theme(axis.text.x = element_text(hjust = 1), # Rotate x-axis labels if needed
panel.grid.major = element_blank(), # Remove major grid lines
panel.border = element_blank(), # Remove panel border
panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
degree(results[[1]])
degree(from_adjacency(results[[1]]))
from_adjacency(results[[1]])
degree(graph_from_adjacency_matrix(results[[1]]))
lapply(results, function(x) degree(graph_from_adjacency_matrix(x)))
do.call("mean",
lapply(results, function(x) degree(graph_from_adjacency_matrix(x))))
degree(graph_from_adjacency_matrix(results[[1]]))
degree(graph_from_adjacency_matrix(results[[1]]),mode = "in")
degree(graph_from_adjacency_matrix(results[[1]]),mode = "out")
degree(graph_from_adjacency_matrix(results[[1]]),loops = F)
results[[1]]
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(c(0,1),p*p, replace = T), ncol = p, nrow = p)
diag(adj_matrix) <- 0
adj_matrix[lower.tri(adj_matrix, diag = F)] <- adj_matrix[upper.tri(adj_matrix, diag = F)]
adj_matrix
}
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
degrees <- lapply(results, function(x) degree(graph_from_adjacency_matrix(x)))
degrees
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(c(0,1),p*p, replace = T), ncol = p, nrow = p)
diag(adj_matrix) <- 0
adj_matrix[lower.tri(adj_matrix, diag = F)] <- t(adj_matrix)[upper.tri(adj_matrix, diag = F)]
isSymmetric.matrix(adj_matrix)
}
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
View(results)
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(c(0,1),p*p, replace = T), ncol = p, nrow = p)
diag(adj_matrix) <- 0
}
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
multiarray <- array(unlist(results), dim = c(nrow(results[[1]]), ncol(results[[1]]), length(results)))
# 1. Melt the matrix (convert to long format)
melted_matrix <- reshape2::melt(apply(X = multiarray, c(1,2), mean))
colnames(melted_matrix) <- c("Row", "Column", "Value") # Better names
melted_matrix <- melted_matrix[order(melted_matrix$Row),]
# 2. Create the heatmap with ggplot2
ggplot(data = melted_matrix, aes(x = Row, y = Column, fill = Value)) +
geom_tile() + # Use geom_tile for the heatmap cells
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) + # Color scale
coord_equal() +  # Important for symmetric matrices: ensures cells are square
theme_minimal() + # Clean theme
theme(axis.text.x = element_text(hjust = 1), # Rotate x-axis labels if needed
panel.grid.major = element_blank(), # Remove major grid lines
panel.border = element_blank(), # Remove panel border
panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
degrees <- lapply(results, function(x) degree(graph_from_adjacency_matrix(x)))
array()
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(c(0,1),p*p, replace = T), ncol = p, nrow = p)
diag(adj_matrix) <- 0
adj_matrix
}
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
multiarray <- array(unlist(results), dim = c(nrow(results[[1]]), ncol(results[[1]]), length(results)))
# 1. Melt the matrix (convert to long format)
melted_matrix <- reshape2::melt(apply(X = multiarray, c(1,2), mean))
colnames(melted_matrix) <- c("Row", "Column", "Value") # Better names
melted_matrix <- melted_matrix[order(melted_matrix$Row),]
# 2. Create the heatmap with ggplot2
ggplot(data = melted_matrix, aes(x = Row, y = Column, fill = Value)) +
geom_tile() + # Use geom_tile for the heatmap cells
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) + # Color scale
coord_equal() +  # Important for symmetric matrices: ensures cells are square
theme_minimal() + # Clean theme
theme(axis.text.x = element_text(hjust = 1), # Rotate x-axis labels if needed
panel.grid.major = element_blank(), # Remove major grid lines
panel.border = element_blank(), # Remove panel border
panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
degrees <- lapply(results, function(x) degree(graph_from_adjacency_matrix(x)))
array()
degrees
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(c(0,1),p*p, replace = T, prob = (0.7,0.3)), ncol = p, nrow = p)
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
multiarray <- array(unlist(results), dim = c(nrow(results[[1]]), ncol(results[[1]]), length(results)))
# 1. Melt the matrix (convert to long format)
melted_matrix <- reshape2::melt(apply(X = multiarray, c(1,2), mean))
colnames(melted_matrix) <- c("Row", "Column", "Value") # Better names
melted_matrix <- melted_matrix[order(melted_matrix$Row),]
# 2. Create the heatmap with ggplot2
ggplot(data = melted_matrix, aes(x = Row, y = Column, fill = Value)) +
geom_tile() + # Use geom_tile for the heatmap cells
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) + # Color scale
coord_equal() +  # Important for symmetric matrices: ensures cells are square
theme_minimal() + # Clean theme
theme(axis.text.x = element_text(hjust = 1), # Rotate x-axis labels if needed
panel.grid.major = element_blank(), # Remove major grid lines
panel.border = element_blank(), # Remove panel border
panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
degrees <- lapply(results, function(x) degree(graph_from_adjacency_matrix(x)))
array()
degrees
degrees <- lapply(results, function(x) degree(graph_from_adjacency_matrix(x,mode = "undirected")))
upper_triangle <- matrix(sample(c(0,1),p * (p + 1) / 2, replace = T, prob = (0.7,0.3)), nrow = p)
upper_triangle <- matrix(sample(c(0,1),p * (p + 1) / 2, replace = T, prob = (0.7,0.3)), nrow = p)
upper_triangle <- matrix(sample(c(0,1),p * (p + 1) / 2, replace = T, prob = c(0.7, 0.3)), nrow = p)
upper_triangle <- matrix(sample(0:1,p * (p + 1) / 2, replace = T, prob = c(0.7, 0.3)), nrow = p)
p
matrix(sample(0:1,p * (p + 1) / 2, replace = T, prob = c(0.7, 0.3)), nrow = p)
p * (p + 1) / 2
adj_matrix[lower.tri(adj_matrix, diag = FALSE)] <- t(upper_triangle)[lower.tri(upper_triangle, diag = FALSE)]
adj_matrix
upper_triangle <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
View(upper_triangle)
# Create the full symmetric matrix by mirroring the upper triangle
adj_matrix <- upper_triangle
adj_matrix[lower.tri(adj_matrix, diag = FALSE)]
t(upper_triangle)[lower.tri(upper_triangle, diag = FALSE)]
upper_triangle <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
# Create the full symmetric matrix by mirroring the upper triangle
adj_matrix <- upper_triangle
adj_matrix[lower.tri(adj_matrix, diag = FALSE)] <- t(upper_triangle)[lower.tri(upper_triangle, diag = FALSE)]
adj_matrix
t(upper_triangle)[lower.tri(upper_triangle, diag = FALSE)]
upper_triangle <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
# Create the full symmetric matrix by mirroring the upper triangle
adj_matrix <- upper_triangle
adj_matrix[lower.tri(adj_matrix, diag = FALSE)] <- t(upper_triangle)[upper.tri(upper_triangle, diag = FALSE)]
adj_matrix
upper_triangle <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
adj_matrix <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
adj_matrix[lower.tri(adj_matrix, diag = FALSE)] <- t(adj_matrix)[upper.tri(adj_matrix, diag = FALSE)]
adj_matrix
lower.tri(adj_matrix, diag = FALSE)
upper.tri(adj_matrix, diag = FALSE)
adj_matrix <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
adj_matrix[lower.tri(adj_matrix, diag = FALSE)] <- adj_matrix[upper.tri(adj_matrix, diag = FALSE)]
adj_matrix
isSymmetric(adj_matrix)
adj_matrix <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
for (i in 1:p){
for (j in 1:p){
adj_matrix[i,j]<- adj_matrix[j,i]
}
}
adj_matrix
isSymmetric.matrix(adj_matrix)
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
for (i in 1:p){
for (j in 1:p){
adj_matrix[i,j]<- adj_matrix[j,i]
}
}
adj_matrix
}
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
multiarray <- array(unlist(results), dim = c(nrow(results[[1]]), ncol(results[[1]]), length(results)))
# 1. Melt the matrix (convert to long format)
melted_matrix <- reshape2::melt(apply(X = multiarray, c(1,2), mean))
colnames(melted_matrix) <- c("Row", "Column", "Value") # Better names
melted_matrix <- melted_matrix[order(melted_matrix$Row),]
# 2. Create the heatmap with ggplot2
ggplot(data = melted_matrix, aes(x = Row, y = Column, fill = Value)) +
geom_tile() + # Use geom_tile for the heatmap cells
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) + # Color scale
coord_equal() +  # Important for symmetric matrices: ensures cells are square
theme_minimal() + # Clean theme
theme(axis.text.x = element_text(hjust = 1), # Rotate x-axis labels if needed
panel.grid.major = element_blank(), # Remove major grid lines
panel.border = element_blank(), # Remove panel border
panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
diag(adj_matrix) <- 0
generate_adj_matrices <- function(p = 10){
adj_matrix <- matrix(sample(0:1,p * p, replace = T, prob = c(0.7, 0.3)), nrow = p)
for (i in 1:p){
for (j in 1:p){
adj_matrix[i,j]<- adj_matrix[j,i]
}
}
diag(adj_matrix) <- 0
adj_matrix
}
results <- list()
for (i in 1:30){
results[[i]] <- generate_adj_matrices(p=10)
}
multiarray <- array(unlist(results), dim = c(nrow(results[[1]]), ncol(results[[1]]), length(results)))
# 1. Melt the matrix (convert to long format)
melted_matrix <- reshape2::melt(apply(X = multiarray, c(1,2), mean))
colnames(melted_matrix) <- c("Row", "Column", "Value") # Better names
melted_matrix <- melted_matrix[order(melted_matrix$Row),]
# 2. Create the heatmap with ggplot2
ggplot(data = melted_matrix, aes(x = Row, y = Column, fill = Value)) +
geom_tile() + # Use geom_tile for the heatmap cells
scale_fill_gradient2(low = "blue", mid = "white", high = "red", midpoint = 0) + # Color scale
coord_equal() +  # Important for symmetric matrices: ensures cells are square
theme_minimal() + # Clean theme
theme(axis.text.x = element_text(hjust = 1), # Rotate x-axis labels if needed
panel.grid.major = element_blank(), # Remove major grid lines
panel.border = element_blank(), # Remove panel border
panel.background = element_blank(), # Remove panel background
axis.ticks = element_blank()) + # Remove axis ticks
labs(title = "Symmetric Heatmap", x = "", y = "") # Add a title
degrees <- lapply(results, function(x) degree(graph_from_adjacency_matrix(x,mode = "undirected")))
degrees
Reduce("mean", degrees)
array(unlist(degrees), dim = c(1,length(degress)))
array(unlist(degrees), dim = c(1,length(degrees)))
unlist(degrees)
array(unlist(degrees), dim = c(length(degrees)))
array(unlist(degrees), dim = c(length(degrees), length(degrees[1])))
array(unlist(degrees), dim = c(length(degrees), length(degrees[[1])))
array(unlist(degrees), dim = c(length(degrees), length(degrees[[1]])))
degrees
do.call("rbind",degrees)
apply(do.call("rbind",degrees), MARGIN = 2, mean)
lapply(results, function(x) degree_distribution(graph_from_adjacency_matrix(x,mode = "undirected")))
setwd("C:/Users/girel/OneDrive/Documentos/DiscreteMarkovNetworkMPI")
list.files("./processed_data")
files <- list.files("./processed_data")
read.csv("./processed_data/arg_mics19-20.csv")
read.csv("./processed_data/arg_mics19-20")
table(data[,-1])
data[,-1]
# Read data
data <- read.csv("./processed_data/arg_mics19-20")
table(data[,-1])
prop.table(table(data[,-1]))
reshape2::melt(prop.table(table(data[,-1])))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies > 0, 1, 0)
as.character(frequencies[,1:10])
apply(frequencies[,1:10], 1, function(x) as.character(x))
apply(frequencies[1:5,1:10], 1, function(x) print(x))
View(frequencies)
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
View(frequencies)
# ggplot
library(ggplot2)
frequencies$country <- "arg_mics19-20"
ggplot(frequencies,
aes(y = value, x = factor(country), fill = positive)) +
geom_bar()
ggplot(frequencies,
aes(y = value, x = factor(country), fill = positive)) +
geom_bar(stat = "identity")
ggplot(frequencies,
geom_bar(stat = "identity")
View(frequencies)
ggplot(frequencies,
aes(y = value, x = factor(country), fill = factor(positive))) +
geom_bar(stat = "identity")
ggplot(frequencies,
aes(y = value, x = factor(country), fill = factor(positive))) +
geom_bar(stat = "count")
ggplot(frequencies,
aes(y = value, x = factor(country), fill = factor(positive))) +
geom_col()
ggplot(frequencies,
aes(y = factor(positive), x = factor(country))) +
geom_col()
names(data_summary)[3] <- "Count" # Rename the count column
data_summary <- aggregate(Value ~ Variable + Value, data = frequencies, FUN = length)
View(frequencies)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length)
View(frequencies)
View(data_summary)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = mean)
View(data_summary)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length())
View(data_summary)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = len)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length)
View(data_summary)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length)
names(data_summary)[2] <- "count" # Rename the count column
data_summary <- with(data_summary, {
Proportion <- ave(count, positive, FUN = function(x) x / sum(x))
})
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length)
names(data_summary)[2] <- "count" # Rename the count column
data_summary <- within(data_summary, {
Proportion <- ave(count, positive, FUN = function(x) x / sum(x))
})
View(data_summary)
sum(data_summary$count)
Proportion <- ave(count)
data_summary <- within(data_summary, {
Proportion <- ave(count)
})
View(data_summary)
data_summary <- within(data_summary, {
Proportion <- mean(count)
})
mean(data_summary$count)
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length)
names(data_summary)[2] <- "count" # Rename the count column
data_summary <- aggregate(value ~ positive + value + country, data = frequencies, FUN = length)
View(data_summary)
934 + 90
data_summary <- aggregate(value ~ positive + value, data = frequencies, FUN = length)
View(data_summary)
plt.data <- aggregate(value ~ positive + value + country, data = frequencies, FUN = length)
View(plt.data)
ggplot(plt.data, aes(fill = factor(positive), y = value, x = country)) +
geom_bar(position = "stack", stat = "identity") +
labs(title = "Proportions of Binary Variables",
x = "Variable",
y = "Proportion",
fill = "Value (0/1)") +
theme_bw() + # A clean theme
scale_fill_manual(values = c("0" = "skyblue", "1" = "darkblue"))
files
setwd("C:/Users/girel/OneDrive/Documentos/DiscreteMarkovNetworkMPI")
# Get all files
files <- list.files("./processed_data")
lapply(files, FUN = function(file){
}
lapply(files, FUN = function(file){
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
frequencies$country <- file
return(frequencies)}
)
frequencies <- lapply(files, FUN = function(file){
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
frequencies$country <- file
return(frequencies)}
)
View(frequencies)
frequencies <- do.call("rbind", frequencies)
files
frequencies <- sapply(files, FUN = function(file){
print(file)
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
frequencies$country <- file
return(frequencies)}
)
frequencies <- do.call("rbind", frequencies)
View(frequencies)
frequencies <- lapply(files, FUN = function(file){
print(file)
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
frequencies$country <- file
return(frequencies)}
)
View(data)
View(frequencies)
frequencies <- do.call("rbind", frequencies)
View(frequencies)
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(value ~ positive + value + country, data = frequencies, FUN = length)
View(plt.data)
# Plot!
library(ggplot2)
ggplot(plt.data, aes(fill = factor(positive), y = value, x = factor(country))) +
geom_bar(position = "stack", stat = "identity") +
labs(title = "Proportions of Binary Variables",
x = "Variable",
y = "Proportion",
fill = "Value (0/1)") +
theme_bw() + # A clean theme
scale_fill_manual(values = c("0" = "skyblue", "1" = "darkblue"))
View(plt.data)
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(value ~ positive + country, data = frequencies, FUN = length)
View(plt.data)
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(value ~ positive + country, data = frequencies, FUN = length)
View(plt.data)
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(value ~ positive + country, data = frequencies, FUN = sum)
View(plt.data)
View(frequencies)
View(plt.data)
# Get all the possible combinations of deprivations
# and calculate their empirical probability (see if positive or not)
frequencies <- lapply(files, FUN = function(file){
print(file)
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
frequencies$country <- factor(file)
return(frequencies)}
)
# convert list into data frame
frequencies <- do.call("rbind", frequencies)
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(positive ~ country, data = frequencies,
FUN = function(x){length(x)/})
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(positive ~ country, data = frequencies,
FUN = function(x){length(x)})
View(plt.data)
frequencies[,frequencies$country == "ben_mics21-22"]
frequencies[frequencies$country == "ben_mics21-22",]
length(frequencies[frequencies$country == "ben_mics21-22",])
dim(frequencies[frequencies$country == "ben_mics21-22",])
file = "ben_mics21-22"
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
View(data)
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
View(frequencies)
frequencies
View(plt.data)
ggplot(plt.data[plt.data$positive == 1024,], aes(fill = factor(positive), y = value, x = factor(country))) +
geom_bar(position = "stack", stat = "identity") +
labs(title = "Proportions of Binary Variables",
x = "Variable",
y = "Proportion",
fill = "Value (0/1)") +
theme_bw() + # A clean theme
scale_fill_manual(values = c("0" = "skyblue", "1" = "darkblue"))
plt.data[plt.data$positive == 1024,
]
View(plt.data)
c
# Get all the possible combinations of deprivations
# and calculate their empirical probability (see if positive or not)
frequencies <- lapply(files, FUN = function(file){
print(file)
# Read data
data <- read.csv(stringr::str_c("./processed_data/",file))
# Frequency tables
frequencies <- reshape2::melt(prop.table(table(data[,-1])))
frequencies$positive <- ifelse(frequencies$value > 0, 1, 0)
frequencies$country <- factor(file)
return(frequencies)}
)
# convert list into data frame
frequencies <- do.call("rbind", frequencies)
# Agregate frequencies by positive and non-positive
plt.data <- aggregate(value ~ positive + country, data = frequencies,
FUN = function(x){length(x)})
View(plt.data)
# Plot!
library(ggplot2)
ggplot(plt.data[plt.data$positive == 1024,], aes(fill = factor(positive), y = value, x = factor(country))) +
geom_bar(position = "stack", stat = "identity") +
labs(title = "Proportions of Binary Variables",
x = "Variable",
y = "Proportion",
fill = "Value (0/1)") +
theme_bw() + # A clean theme
scale_fill_manual(values = c("0" = "skyblue", "1" = "darkblue"))
View(plt.data)
ggplot(plt.data, aes(fill = factor(positive), y = value, x = factor(country))) +
geom_bar(position = "stack", stat = "identity") +
labs(title = "Proportions of Binary Variables",
x = "Variable",
y = "Proportion",
fill = "Value (0/1)") +
theme_bw() + # A clean theme
scale_fill_manual(values = c("0" = "skyblue", "1" = "darkblue"))
